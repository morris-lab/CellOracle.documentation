

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>celloracle.trajectory.oracle_core &mdash; celloracle 0.1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> celloracle
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Welcome to celloracleâ€™s documentation!</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/index.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license/index.html">License</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../citation/index.html">Authors and citations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">celloracle</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>celloracle.trajectory.oracle_core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for celloracle.trajectory.oracle_core</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">..utility.hdf5_processing</span> <span class="k">import</span> <span class="n">dump_hdf5</span><span class="p">,</span> <span class="n">load_hdf5</span>

<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>

<span class="kn">from</span> <span class="nn">.sankey</span> <span class="k">import</span> <span class="n">sankey</span>
<span class="kn">from</span> <span class="nn">.markov_simulation</span> <span class="k">import</span> <span class="n">_walk</span>
<span class="kn">from</span> <span class="nn">.oracle_utility</span> <span class="k">import</span> <span class="p">(</span><span class="n">_adata_to_matrix</span><span class="p">,</span> <span class="n">_adata_to_df</span><span class="p">,</span>
                             <span class="n">_adata_to_color_dict</span><span class="p">,</span> <span class="n">_get_clustercolor_from_anndata</span><span class="p">,</span>
                             <span class="n">_numba_random_seed</span><span class="p">,</span> <span class="n">_linklist2dict</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.oracle_GRN</span> <span class="k">import</span> <span class="n">_do_simulation</span><span class="p">,</span> <span class="n">_getCoefMatrix</span>
<span class="kn">from</span> <span class="nn">.modified_VelocytoLoom_class</span> <span class="k">import</span> <span class="n">modified_VelocytoLoom</span>
<span class="kn">from</span> <span class="nn">..network_analysis.network_construction</span> <span class="k">import</span> <span class="n">get_links</span>



<span class="k">def</span> <span class="nf">load_oracle</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load oracle object saved as hdf5 file.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_path (str): File path to the hdf5 file.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">load_hdf5</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">file_path</span><span class="p">,</span> <span class="n">obj_class</span><span class="o">=</span><span class="n">Oracle</span><span class="p">)</span>


<div class="viewcode-block" id="Oracle"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle">[docs]</a><span class="k">class</span> <span class="nc">Oracle</span><span class="p">(</span><span class="n">modified_VelocytoLoom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Oracle is the main class in CellOracle. Oracle object imports scRNA-seq data (anndata) and TF information to infer cluster-specific GRNs. It can predict the future gene expression patterns and cell state transitions in response to  the perturbation of TFs. Please see the CellOracle paper for details.</span>
<span class="sd">    The code of the Oracle class was made of the three components below.</span>

<span class="sd">    (1) Anndata: Gene expression matrix and metadata from single-cell RNA-seq are stored in the anndata object. Processed values, such as normalized counts and simulated values, are stored as layers of anndata. Metadata (i.e., Cluster info) are saved in anndata.obs. Refer to scanpy/anndata documentation for detail.</span>

<span class="sd">    (2) Net: Net is a custom class in celloracle. Net object processes several data to infer GRN. See the Net class documentation for details.</span>

<span class="sd">    (3) VelycytoLoom: Calculation of transition probability and visualization of directed trajectory graph will be performed in the same way as velocytoloom. VelocytoLoom is class from Velocyto, a python library for RNA-velocity analysis. In celloracle, we use some functions in velocytoloom for the visualization.</span>


<span class="sd">    Attributes:</span>
<span class="sd">        adata (anndata): Imported anndata object</span>
<span class="sd">        cluster_column_name (str): The column name in adata.obs containing cluster info</span>
<span class="sd">        embedding_name (str): The key name in adata.obsm containing dimensional reduction cordinates</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">############################</span>
    <span class="c1">### 0. utility functions ###</span>
    <span class="c1">############################</span>
<div class="viewcode-block" id="Oracle.copy"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deepcopy itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Oracle.to_hdf5"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.to_hdf5">[docs]</a>    <span class="k">def</span> <span class="nf">to_hdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save object as hdf5.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_path (str): file path to save file. Filename needs to end with &#39;.celloracle.oracle&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.celloracle.oracle&quot;</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filename needs to end with &#39;.celloracle.oracle&#39;&quot;</span><span class="p">)</span>

        <span class="n">compression_opts</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">dump_hdf5</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">file_path</span><span class="p">,</span>
                  <span class="n">data_compression</span><span class="o">=</span><span class="n">compression_opts</span><span class="p">,</span>  <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                  <span class="n">noarray_compression</span><span class="o">=</span><span class="n">compression_opts</span><span class="p">,</span> <span class="n">pickle_protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


    <span class="c1">###################################</span>
    <span class="c1">### 1. Methods for loading data ###</span>
    <span class="c1">###################################</span>

<div class="viewcode-block" id="Oracle.import_TF_data"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.import_TF_data">[docs]</a>    <span class="k">def</span> <span class="nf">import_TF_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">TF_info_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">TF_info_matrix_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">TFdict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load data about potential-regulatory TFs.</span>
<span class="sd">        You can import either TF_info_matrix or TFdict.</span>
<span class="sd">        For more information on how to make these files, please see the motif analysis module within the celloracle tutorial.</span>

<span class="sd">        Args:</span>
<span class="sd">            TF_info_matrix (pandas.DataFrame): TF_info_matrix.</span>

<span class="sd">            TF_info_matrix_path (str): File path for TF_info_matrix (pandas.DataFrame).</span>

<span class="sd">            TFdict (dictionary): Python dictionary of TF info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">TF_info_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">TF_info_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;peak_id&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;gene_short_name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">TF_info_matrix_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">TF_info_matrix_path</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;peak_id&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;gene_short_name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">TFdict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">=</span><span class="n">TFdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Oracle.updateTFinfo_dictionary"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.updateTFinfo_dictionary">[docs]</a>    <span class="k">def</span> <span class="nf">updateTFinfo_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">TFdict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update a TF dictionary.</span>
<span class="sd">        If a key in the new TF dictionary already exists in the old TF dictionary, old values will be replaced with a new one.</span>

<span class="sd">        Args:</span>
<span class="sd">            TFdict (dictionary): Python dictionary of TF info.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">TFdict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Oracle.addTFinfo_dictionary"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.addTFinfo_dictionary">[docs]</a>    <span class="k">def</span> <span class="nf">addTFinfo_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">TFdict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add new TF info to pre-existing TFdict.</span>
<span class="sd">        Values in the old TF dictionary will remain.</span>

<span class="sd">        Args:</span>
<span class="sd">            TFdict (dictionary): Python dictionary of TF info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">TFdict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span>
                <span class="n">targets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">TFdict</span><span class="p">[</span><span class="n">tf</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
                <span class="n">targets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">tf</span><span class="p">:</span> <span class="n">targets</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">tf</span><span class="p">:</span> <span class="n">TFdict</span><span class="p">[</span><span class="n">tf</span><span class="p">]})</span></div>

<div class="viewcode-block" id="Oracle.get_cluster_specific_TFdict_from_Links"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.get_cluster_specific_TFdict_from_Links">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_specific_TFdict_from_Links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">links_object</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract TF and its target gene information from Links object.</span>
<span class="sd">        This function can be used to reconstruct GRNs based on pre-existing GRNs saved in Links object.</span>

<span class="sd">        Args:</span>
<span class="sd">            links_object (Links): Please see the explanation of Links class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">links_object</span><span class="o">.</span><span class="n">filtered_links</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_linklist2dict</span><span class="p">(</span><span class="n">links_object</span><span class="o">.</span><span class="n">filtered_links</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>

<div class="viewcode-block" id="Oracle.import_anndata_as_raw_count"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.import_anndata_as_raw_count">[docs]</a>    <span class="k">def</span> <span class="nf">import_anndata_as_raw_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">cluster_column_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">embedding_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">transform</span><span class="o">=</span><span class="s2">&quot;natural_log&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load scRNA-seq data. scRNA-seq data should be prepared as an anndata object.</span>
<span class="sd">        Preprocessing (cell and gene filtering, dimensional reduction, clustering, etc.) should be done before loading data.</span>
<span class="sd">        The method imports RAW GENE COUNTS because unscaled and uncentered gene expression data are required for the GRN inference and simulation.</span>
<span class="sd">        See tutorial notebook for the details about how to process scRNA-seq data.</span>

<span class="sd">        Args:</span>
<span class="sd">            adata (anndata): anndata object that stores scRNA-seq data.</span>

<span class="sd">            cluster_column_name (str): the name of column containing cluster information in anndata.obs.</span>
<span class="sd">                Clustering data should be in anndata.obs.</span>

<span class="sd">            embedding_name (str): the key name for dimensional reduction information in anndata.obsm.</span>
<span class="sd">                Dimensional reduction (or 2D trajectory graph) should be in anndata.obsm.</span>

<span class="sd">            transform (str): The method for log-transformation. Chose one from &quot;natural_log&quot; or &quot;log2&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gene expression matrix (adata.X) does not seems to be raw_count because it contains negavive values.&quot;</span><span class="p">)</span>

        <span class="c1"># store data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span> <span class="o">=</span> <span class="n">cluster_column_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_name</span> <span class="o">=</span> <span class="n">embedding_name</span>

        <span class="c1">#if hasattr(self.adata, &quot;raw&quot;):</span>
        <span class="c1">#    self.adata.X = self.adata.raw.X.copy()</span>

        <span class="c1"># store raw count data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;raw_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># log transformation</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;log2&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;natural_log&quot;</span><span class="p">:</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;normalized_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># update color information</span>
        <span class="n">col_dict</span> <span class="o">=</span> <span class="n">_get_clustercolor_from_anndata</span><span class="p">(</span><span class="n">adata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span>
                                                  <span class="n">cluster_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">,</span>
                                                  <span class="n">return_as</span><span class="o">=</span><span class="s2">&quot;dict&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">col_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]])</span>

        <span class="c1"># variable gene detection for the QC of simulation</span>
        <span class="sd">&quot;&quot;&quot;N = adata.shape[1]</span>
<span class="sd">        if N &gt;= 3000:</span>
<span class="sd">            N = 3000</span>
<span class="sd">        n = int(N/3)-1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_cv_vs_mean</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_expr_avg</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high_var_genes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Oracle.import_anndata_as_normalized_count"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.import_anndata_as_normalized_count">[docs]</a>    <span class="k">def</span> <span class="nf">import_anndata_as_normalized_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">cluster_column_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">embedding_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load scRNA-seq data. scRNA-seq data should be prepared as an anndata object.</span>
<span class="sd">        Preprocessing (cell and gene filtering, dimensional reduction, clustering, etc.) should be done before loading data.</span>
<span class="sd">        The method will import NORMALIZED and LOG TRANSFORMED data but NOT SCALED and NOT CENTERED data.</span>
<span class="sd">        See the tutorial for more details on how to process scRNA-seq data.</span>

<span class="sd">        Args:</span>
<span class="sd">            adata (anndata): anndata object containing scRNA-seq data.</span>

<span class="sd">            cluster_column_name (str): the name of column containing cluster information in anndata.obs.</span>
<span class="sd">                Clustering data should be in anndata.obs.</span>

<span class="sd">            embedding_name (str): the key name for dimensional reduction information in anndata.obsm.</span>
<span class="sd">                Dimensional reduction (or 2D trajectory graph) should be in anndata.obsm.</span>

<span class="sd">            transform (str): The method for log-transformation. Chose one from &quot;natural_log&quot; or &quot;log2&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gene expression matrix (adata.X) contains negavive values. Please use UNSCALED and UNCENTERED data.&quot;</span><span class="p">)</span>

        <span class="c1"># store data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span> <span class="o">=</span> <span class="n">cluster_column_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_name</span> <span class="o">=</span> <span class="n">embedding_name</span>

        <span class="c1"># store raw count data</span>
        <span class="c1">#self.adata.layers[&quot;raw_count&quot;] = adata.X.copy()</span>

        <span class="c1"># normalization and log transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;normalized_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># update color information</span>
        <span class="n">col_dict</span> <span class="o">=</span> <span class="n">_get_clustercolor_from_anndata</span><span class="p">(</span><span class="n">adata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span>
                                                  <span class="n">cluster_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">,</span>
                                                  <span class="n">return_as</span><span class="o">=</span><span class="s2">&quot;dict&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">col_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]])</span>

        <span class="c1"># variable gene detection for the QC of simulation</span>
        <span class="sd">&quot;&quot;&quot;N = adata.shape[1]</span>
<span class="sd">        if N &gt;= 3000:</span>
<span class="sd">            N = 3000</span>
<span class="sd">        n = int(N/3)-1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_cv_vs_mean</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_expr_avg</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high_var_genes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected_genes</span> <span class="o">=</span> <span class="kc">None</span></div>



    <span class="c1">####################################</span>
    <span class="c1">### 2. Methods for GRN inference ###</span>
    <span class="c1">####################################</span>
<div class="viewcode-block" id="Oracle.fit_GRN_for_simulation"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.fit_GRN_for_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">fit_GRN_for_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GRN_unit</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_cluster_specific_TFdict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do GRN inference.</span>
<span class="sd">        Please see the paper of CellOracle paper for details.</span>

<span class="sd">        GRN can be constructed for the entire population or each clusters.</span>
<span class="sd">        If you want to infer cluster-specific GRN, please set [GRN_unit=&quot;cluster&quot;].</span>
<span class="sd">        You can select cluster information when you import data.</span>

<span class="sd">        If you set [GRN_unit=&quot;whole&quot;], GRN will be made using all cells.</span>

<span class="sd">        Args:</span>
<span class="sd">            GRN_unit (str): Select &quot;cluster&quot; or &quot;whole&quot;</span>

<span class="sd">            alpha (float or int): The strength of regularization.</span>
<span class="sd">                If you set a lower value, the sensitivity increases, and you can detect weaker network connections. However, there may be more noise.</span>
<span class="sd">                If you select a higher value, it will reduce the chance of overfitting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prepare data for GRN calculation</span>
        <span class="n">gem_imputed</span> <span class="o">=</span> <span class="n">_adata_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="s2">&quot;imputed_count&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;simulation_input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;imputed_count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_for_trajectory_GRN</span> <span class="o">=</span> <span class="n">alpha</span>

        <span class="k">if</span> <span class="n">use_cluster_specific_TFdict</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">cluster_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]</span>

            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;fitting GRN again...&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_info</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;calculating GRN in </span><span class="si">{cluster}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">cells_in_the_cluster_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_info</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span>
                <span class="n">gem_</span> <span class="o">=</span> <span class="n">gem_imputed</span><span class="p">[</span><span class="n">cells_in_the_cluster_bool</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">_getCoefMatrix</span><span class="p">(</span><span class="n">gem</span><span class="o">=</span><span class="n">gem_</span><span class="p">,</span>
                                                                       <span class="n">TFdict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_specific_TFdict</span><span class="p">[</span><span class="n">cluster</span><span class="p">],</span>
                                                                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">GRN_unit</span> <span class="o">==</span> <span class="s2">&quot;whole&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix</span> <span class="o">=</span> <span class="n">_getCoefMatrix</span><span class="p">(</span><span class="n">gem</span><span class="o">=</span><span class="n">gem_imputed</span><span class="p">,</span> <span class="n">TFdict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">GRN_unit</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">cluster_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_info</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;calculating GRN in </span><span class="si">{cluster}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">cells_in_the_cluster_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_info</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span>
                    <span class="n">gem_</span> <span class="o">=</span> <span class="n">gem_imputed</span><span class="p">[</span><span class="n">cells_in_the_cluster_bool</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">_getCoefMatrix</span><span class="p">(</span><span class="n">gem</span><span class="o">=</span><span class="n">gem_</span><span class="p">,</span>
                                                                           <span class="n">TFdict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TFdict</span><span class="p">,</span>
                                                                           <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span></div>



    <span class="c1">#######################################################</span>
    <span class="c1">### 3. Methods for simulation of signal propagation ###</span>
    <span class="c1">#######################################################</span>

<div class="viewcode-block" id="Oracle.simulate_shift"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.simulate_shift">[docs]</a>    <span class="k">def</span> <span class="nf">simulate_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perturb_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">GRN_unit</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span>
                       <span class="n">n_propagation</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ignore_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate signal propagation with GRNs. Please see the CellOracle paper for details.</span>
<span class="sd">        This function simulates a gene expression pattern in the near future.</span>
<span class="sd">        Simulated values will be stored in anndata.layers: [&quot;simulated_count&quot;]</span>


<span class="sd">        The simulation use three types of data.</span>
<span class="sd">        (1) GRN inference results (coef_matrix).</span>
<span class="sd">        (2) Perturb_condition: You can set arbitrary perturbation condition.</span>
<span class="sd">        (3) Gene expression matrix: The simulation starts from imputed gene expression data.</span>

<span class="sd">        Args:</span>
<span class="sd">            perturb_condition (dictionary): condition for perturbation.</span>
<span class="sd">               if you want to simulate knockout for GeneX, please set [perturb_condition={&quot;GeneX&quot;: 0.0}]</span>
<span class="sd">               Although you can set any non-negative values for the gene condition, avoid setting biologically infeasible values for the perturb condition.</span>
<span class="sd">               It is strongly recommended to check gene expression values in your data before selecting the perturb condition.</span>

<span class="sd">            GRN_unit (str): GRN type. Please select either &quot;whole&quot; or &quot;cluster&quot;. See the documentation of &quot;fit_GRN_for_simulation&quot; for the detailed explanation.</span>

<span class="sd">            n_propagation (int): Calculation will be performed iteratively to simulate signal propagation in GRN.</span>
<span class="sd">                You can set the number of steps for this calculation.</span>
<span class="sd">                With a higher number, the results may recapitulate signal propagation for many genes.</span>
<span class="sd">                However, a higher number of propagation may cause more error/noise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 0. Reset previous simulation results if it exist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="c1"># 1. prepare perturb information</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">perturb_condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perturb_condition</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_var_genes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ignore_warning</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Variability score of Gene </span><span class="si">{i}</span><span class="s2"> is too low. Simulation accuracy may be poor with this gene.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Variability score of Gene </span><span class="si">{i}</span><span class="s2"> is too low. Cannot perform simulation.&quot;</span><span class="p">)</span>

            <span class="c1"># reset simulation initiation point</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;simulation_input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;imputed_count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">simulation_input</span> <span class="o">=</span> <span class="n">_adata_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="s2">&quot;simulation_input&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perturb_condition</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">simulation_input</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{i}</span><span class="s2"> is not in the data&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">simulation_input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perturb_condition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">simulation_input</span> <span class="o">=</span> <span class="n">_adata_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="s2">&quot;simulation_input&quot;</span><span class="p">)</span>

        <span class="c1"># 2. load gene expression matrix (initiation information for the simulation)</span>
        <span class="n">gem_imputed</span> <span class="o">=</span> <span class="n">_adata_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="s2">&quot;imputed_count&quot;</span><span class="p">)</span>

        <span class="c1"># 3. do simulation for signal propagation within GRNs</span>
        <span class="k">if</span> <span class="n">GRN_unit</span> <span class="o">==</span> <span class="s2">&quot;whole&quot;</span><span class="p">:</span>
            <span class="n">gem_simulated</span> <span class="o">=</span> <span class="n">_do_simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix</span><span class="p">,</span>
                                           <span class="n">simulation_input</span><span class="p">,</span>
                                           <span class="n">gem_imputed</span><span class="p">,</span>
                                           <span class="n">n_propagation</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">GRN_unit</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>
            <span class="n">simulated</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cluster_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_name</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_info</span><span class="p">):</span>
                <span class="n">cells_in_the_cluster_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_info</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span>

                <span class="n">simulation_input_</span> <span class="o">=</span> <span class="n">simulation_input</span><span class="p">[</span><span class="n">cells_in_the_cluster_bool</span><span class="p">]</span>
                <span class="n">gem_</span> <span class="o">=</span> <span class="n">gem_imputed</span><span class="p">[</span><span class="n">cells_in_the_cluster_bool</span><span class="p">]</span>

                <span class="n">simulated_in_the_cluster</span> <span class="o">=</span> <span class="n">_do_simulation</span><span class="p">(</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">coef_matrix_per_cluster</span><span class="p">[</span><span class="n">cluster</span><span class="p">],</span>
                                             <span class="n">simulation_input_</span><span class="p">,</span>
                                             <span class="n">gem_</span><span class="p">,</span>
                                             <span class="n">n_propagation</span><span class="p">)</span>
                <span class="n">simulated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simulated_in_the_cluster</span><span class="p">)</span>
            <span class="n">gem_simulated</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">simulated</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gem_simulated</span> <span class="o">=</span> <span class="n">gem_simulated</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">gem_imputed</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;GRN_unit shold be either of &#39;whole&#39; or &#39;cluster&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># 4. store simulation results</span>
        <span class="c1">#  simulated future gene expression matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;simulated_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gem_simulated</span><span class="o">.</span><span class="n">values</span>

        <span class="c1">#  difference between simulated values and original values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;delta_X&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;simulated_count&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;imputed_count&quot;</span><span class="p">]</span></div>


    <span class="c1">########################################</span>
    <span class="c1">### 4. Methods for Markov simulation ###</span>
    <span class="c1">########################################</span>
<div class="viewcode-block" id="Oracle.prepare_markov_simulation"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.prepare_markov_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_markov_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pick up cells for Markov simulation.</span>

<span class="sd">        Args:</span>
<span class="sd">            verbose (bool): If True, it plots selected cells.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sample uniformly the points to avoid density driven effects - Should reimplement as a method</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span>
        <span class="n">grs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="n">dim_i</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="n">dim_i</span><span class="p">])</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mf">0.025</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="mf">0.025</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">gr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">steps</span><span class="p">[</span><span class="n">dim_i</span><span class="p">])</span>
            <span class="n">grs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>

        <span class="n">meshes_tuple</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grs</span><span class="p">)</span>
        <span class="n">gridpoints_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">flat</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">meshes_tuple</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">()</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ixs</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">gridpoints_coordinates</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">diag_step_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">meshes_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">meshes_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">meshes_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">meshes_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">diag_step_dist</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">ixs</span> <span class="o">=</span> <span class="n">ixs</span><span class="p">[</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">]</span>
        <span class="n">gridpoints_coordinates</span> <span class="o">=</span> <span class="n">gridpoints_coordinates</span><span class="p">[</span><span class="n">dist</span><span class="o">.</span><span class="n">flat</span><span class="p">[:]</span><span class="o">&lt;</span><span class="n">min_dist</span><span class="p">,:]</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">]</span>

        <span class="n">ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ixs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span> <span class="o">=</span> <span class="n">ixs</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">ixs</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">ixs</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">[</span><span class="n">ixs</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                        <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;0.4&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_markov</span><span class="p">(</span><span class="n">sigma_D</span><span class="o">=</span><span class="n">diag_step_dist</span><span class="p">,</span> <span class="n">sigma_W</span><span class="o">=</span><span class="n">diag_step_dist</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span>
                       <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">cells_ixs</span><span class="o">=</span><span class="n">ixs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Oracle.run_markov_chain_simulation"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.run_markov_chain_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">run_markov_chain_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">n_duplication</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do Markov simlations to predict cell transition after perturbation.</span>
<span class="sd">        The transition probability between cells has been calculated</span>
<span class="sd">        based on simulated gene expression values in the signal propagation process.</span>
<span class="sd">        The cell state transition will be simulated based on the probability.</span>
<span class="sd">        You can simulate the process multiple times to get a robust outcome.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_steps (int): steps for Markov simulation. This value is equivalent to the amount of time after perturbation.</span>

<span class="sd">            n_duplication (int): the number for multiple calculations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">_numba_random_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_markov_simulation</span><span class="p">()</span>

        <span class="n">transition_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">n_cells</span> <span class="o">=</span> <span class="n">transition_prob</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">start_cell_id_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_cells</span><span class="p">),</span> <span class="n">n_duplication</span><span class="p">)</span>

        <span class="n">transition</span> <span class="o">=</span> <span class="n">_walk</span><span class="p">(</span><span class="n">start_cell_id_array</span><span class="p">,</span> <span class="n">transition_prob</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">)</span>
        <span class="n">transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span><span class="p">[</span><span class="n">transition</span><span class="p">]</span>

        <span class="n">li</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixs_mcmc</span><span class="p">,</span> <span class="n">n_duplication</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span></div>

<div class="viewcode-block" id="Oracle.summarize_mc_results_by_cluster"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.summarize_mc_results_by_cluster">[docs]</a>    <span class="k">def</span> <span class="nf">summarize_mc_results_by_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_use</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function summarizes the simulated cell state-transition by groping the results into each cluster.</span>
<span class="sd">        It returns sumarized results as a pandas.DataFrame.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_use (str): cluster information name in anndata.obs.</span>
<span class="sd">               You can use any arbitrary cluster information in anndata.obs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">values</span>
        <span class="n">mcmc_transition_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_use</span><span class="p">])[</span><span class="n">transition</span><span class="p">]</span>
        <span class="n">mcmc_transition_cluster</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mcmc_transition_cluster</span><span class="p">,</span>
                                               <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mcmc_transition_cluster</span></div>


<div class="viewcode-block" id="Oracle.plot_mc_resutls_as_sankey"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.plot_mc_resutls_as_sankey">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mc_resutls_as_sankey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_use</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the simulated cell state-transition as a Sankey-diagram after groping by the cluster.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_use (str): cluster information name in anndata.obs.</span>
<span class="sd">               You can use any cluster information in anndata.obs.</span>

<span class="sd">            start (int): The starting point of Sankey-diagram. Please select a  step in the Markov simulation.</span>

<span class="sd">            end (int): The end point of Sankey-diagram. Please select a  step in the Markov simulation.</span>
<span class="sd">                if you set [end=-1], the final step of Markov simulation will be used.</span>

<span class="sd">            order (list of str): The order of cluster name in the Sankey-diagram.</span>

<span class="sd">            font_size (int): Font size for cluster name label in the Sankey diagram.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mcmc_transition_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_mc_results_by_cluster</span><span class="p">(</span><span class="n">cluster_use</span><span class="p">)</span>
        <span class="n">mcmc_color_dict</span> <span class="o">=</span>  <span class="n">_adata_to_color_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="p">,</span> <span class="n">cluster_use</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">mcmc_transition_cluster</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]]</span>
        <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order_</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">order_</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">order_left</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order_</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">unique</span><span class="p">()]</span>
            <span class="n">order_right</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order_</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">unique</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order_left</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
            <span class="n">order_right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

        <span class="n">sankey</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">],</span>
               <span class="n">aspect</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">font_size</span><span class="p">,</span>
               <span class="n">colorDict</span><span class="o">=</span><span class="n">mcmc_color_dict</span><span class="p">,</span>
               <span class="n">leftLabels</span><span class="o">=</span><span class="n">order_left</span><span class="p">,</span> <span class="n">rightLabels</span><span class="o">=</span><span class="n">order_right</span><span class="p">)</span></div>


<div class="viewcode-block" id="Oracle.plot_mc_result_as_kde"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.plot_mc_result_as_kde">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mc_result_as_kde</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_time</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pick up one timepoint in the cell state-transition simulation and plot as a kde plot.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_time (int): the number in Markov simulation</span>

<span class="sd">            args (dictionary): An argument for seaborn.kdeplot.</span>
<span class="sd">                See seaborn documentation for details (https://seaborn.pydata.org/generated/seaborn.kdeplot.html#seaborn.kdeplot).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">n_time</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">sns</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Oracle.plot_mc_result_as_trajectory"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.plot_mc_result_as_trajectory">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mc_result_as_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_name</span><span class="p">,</span> <span class="n">time_range</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pick up several timepoints in the cell state-transition simulation and plot as a line plot.</span>
<span class="sd">        This function can be used to visualize how cell-state changes after perturbation focusing on a specific cell.</span>

<span class="sd">        Args:</span>
<span class="sd">            cell_name (str): cell name. chose from adata.obs.index</span>

<span class="sd">            time_range (list of int): the list of index in Markov simulation</span>

<span class="sd">            args (dictionary): dictionary for the arguments for matplotlib.pyplit.plot.</span>
<span class="sd">                See matplotlib documentation for details (https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">cell_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cell_ix_in_mcmctid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">cell_ix</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># plot all cells in gray color</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;lightgray&quot;</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cell_ix_in_mcmctid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_plot_one_trajectory</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">time_range</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

        <span class="c1"># plot cell of interest (initiation point of simulation) in red color</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_plot_one_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ix_in_mcmctid</span><span class="p">,</span> <span class="n">time_range</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{}):</span>
        <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_transition_id</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">cell_ix_in_mcmctid</span><span class="p">,:]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">time_range</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">tt</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">tt</span><span class="p">],</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>


    <span class="c1">###################################################</span>
    <span class="c1">### 5. GRN inference for Network score analysis ###</span>
    <span class="c1">###################################################</span>
<div class="viewcode-block" id="Oracle.get_links"><a class="viewcode-back" href="../../../modules/celloracle.html#celloracle.Oracle.get_links">[docs]</a>    <span class="k">def</span> <span class="nf">get_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_name_for_GRN_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bagging_number</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">verbose_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">test_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes GRN for each cluster and returns results as a Links object.</span>
<span class="sd">        Several preprocessing should be done before using this function.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_name_for_GRN_unit (str): Cluster name for GRN calculation. The cluster information should be stored in Oracle.adata.obs.</span>

<span class="sd">            alpha (float or int): The strength of regularization.</span>
<span class="sd">                If you set a lower value, the sensitivity increases, and you can detect weaker network connections. However, there may be more noise.</span>
<span class="sd">                If you select a higher value, it will reduce the chance of overfitting.</span>

<span class="sd">            bagging_number (int): The number used in bagging calculation.</span>


<span class="sd">            verbose_level (int): if [verbose_level&gt;1], most detailed progress information will be shown.</span>
<span class="sd">                if [verbose_level &gt; 0], one progress bar will be shown.</span>
<span class="sd">                if [verbose_level == 0], no progress bar will be shown.</span>

<span class="sd">            test_mode (bool): If test_mode is True, GRN calculation will be done for only one cluster rather than all clusters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">get_links</span><span class="p">(</span><span class="n">oracle_object</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">cluster_name_for_GRN_unit</span><span class="o">=</span><span class="n">cluster_name_for_GRN_unit</span><span class="p">,</span>
                          <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">bagging_number</span><span class="o">=</span><span class="n">bagging_number</span><span class="p">,</span>
                          <span class="n">verbose_level</span><span class="o">=</span><span class="n">verbose_level</span><span class="p">,</span> <span class="n">test_mode</span><span class="o">=</span><span class="n">test_mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">links</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Samantha Morris Lab

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>